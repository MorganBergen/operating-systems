#  main memory

##  what is main memory

**central role** -  key to computer operation

**structure** -  large array of words/bytes

**function** -  rapidly accessible info for cpu and i/o devices

**usage** -  stores active programs and data

**speed** -  fast data transfer with the processor

**also known as** -  ram (random access memory)

**volatility** -  loses data on power loss

##  cache

**high speed memory** -  special, very fast memory

**smaller & faster** -  stores copies of frequently used main memory data

**multiple caches** -  independent caches in a cpu for instructions and data

**purpose** -  reduces average time to access data from main memory

##  logical and physical address space

**logical address space**

generated by the cpu

also called virtual address

defines the size of the process

can be changed

**physical address space*8

seen by the memory unit

also called a real address

computed by the memory management unit (mmu)

maps from logical addresses

##  address binding

compiled code addresses bind to relocatable addresses.  

can happen at three stages - compile time, load time, and execution time

##  memory management unit (mmu)

maps virtual to physical address

simple scheme - relocation register adds base value to address

##  swapping

allows total physical memory space of processes to exceed physical memory.  

process swapped out temporarily to backing store, then brought back for execution

##  backing store and swapping variants 

backing store

fast disk for storing copies of all memory images

function -  holds overflow data form ram

roll out, roll in

swapping variant for priority based scheduling

roll out -  moves low priority processes to backing store

roll in -  loads high priority processes into main memory

##  dynamic storage allocation problem

| fit | method | pros | cons |
|:---|:---|:---|:---|
| first fit | first available block | fast | fragmentation |
| best fit | smallest suitable block | minimizes wasted space | slow, small fragments |
| worst fit | largest available block | reduces small fragments | inefficient use of memory |

##  example

consider a swapping system in which memory consists of the following whole sizes in memory order: `10k`, `4k`, `20k` `18k`, `7k`, `9k`, `12k`, and `15k`.  which hole is taken for successive segment request of  i.  `12k`, ii.  `10k`, iii.  `9k` for first fit?  now repeat the question fro best fit and worst fit

| first fit | best fit | worst fit |
|:----------|:----------|:----------|
| `12k` $\rightarrow$ `20k` | `12k` $\rightarrow$ `12k` | `12k` $\rightarrow$ `20k` |
| `10k` $\rightarrow$ `10k` | `10k` $\rightarrow$ `10k` | `10k` $\rightarrow$ `18k` |
| `9k` $\rightarrow$ `18k` | `9k` $\rightarrow$ `9k` | `9k` $\rightarrow$ `15k` |

##  fragmentation

external fragmentation 

definition -  non-contiguous free memory blocks

cause -  allocation and deallocation of memory over time

problem -  insufficient continuous space for new allocations despite total free space being adequate

internal fragmentation

definition -  allocated memory slightly larger than requested

cause -  fixed sized memory blocks

problem -  wasted space within allocated regions
 
##  paging

physical memory divided into fixed sized frames

logical memory divided into pages

page table translates logical to physical addresses

##  address translation 

page number `p` - identifies the page in memory

page offset `d` - specifies the position within the page

address translation -  uses page number and offset to locate data in memory

##  transition look aside buffer (tlb)

cpu cache for fast virtual address translation

features -  small size, associative mapping, loads data on tlb miss

##  page table protection

**components**

**valid bit** -  indicates if the mapping is valid

**invalid bit** -  marks the mapping as invalid

**purpose**

protects memory regions from unauthorized access

ensures data integrity by controlling access permissions

##  multilevel and hashed page tables

**multilevel page tables**

hierarchical organization for efficient memory management

divides large address spaces into smaller, manageable units

**hashed page tables**

virtual page number hashed into page table for faster access

offers a more direct mapping approach, reducing lookup time

##  segment table